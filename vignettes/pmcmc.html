<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Akira Endo" />


<title>Particle Markov-chain Monte Carlo with {idmodelr}</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Particle Markov-chain Monte Carlo with {idmodelr}</h1>
<h4 class="author">Akira Endo</h4>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(idmodelr)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">#&gt; Warning: package &#39;idmodelr&#39; was built under R version 3.6.2</span></a></code></pre></div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This vignette is to introduce to the {idmodelr} package users a simple use example of the particle Markov-chain Monte Carlo (PMCMC) algorithm. We take simple deterministic/stochastic epidemic models with partial observation as model cases and show how the models are coupled with PMCMC for efficient parameter estimation.</p>
<p>Infectious disease modelling often involves handling of time-series datasets with partial (or modified) observation. A familiar example of the partial observation is underreporting, where only a certain fraction of infected individuals are identified and recorded in the dataset. One can account for the observation processes by explicitly incorporating them into the model, but this approach can lead to a particular class of model called “hidden Markov process (HMP)”, whose likelihood is usually intractable.</p>
<p>HMPs are typically represented as a Markov process with hidden inner states and its observation. Namely, the hidden variable <span class="math inline">\(x_t\)</span> evolves over time according to the time-evolution process <span class="math inline">\(f\)</span> and only <span class="math inline">\(y_t\)</span>, the observed variable subject to the observation process <span class="math inline">\(g\)</span>, is available as the model output.</p>
<p><span class="math display">\[\begin{matrix}
x_t &amp; \sim &amp; f(x_t;x_{t-1}) \\
y_t &amp;\sim &amp;g(y_t;x_t)
\end{matrix}
\]</span></p>
<p>The likelihood of this HMP given the data <span class="math inline">\(\{y_1,y_2,...,y_T\}\)</span> should theoretically be obtained by integrating out hidden variables <span class="math inline">\(x_t\)</span>’s; however, this integration is computationally too heavy in practice due to high dimensionality.</p>
<p><span class="math display">\[
\mathcal L=\int\int...\int \left( p(x_1)g(y_1;x_1)\sum_{t=2}^T {f(x_t;x_{t-1})g(y_t;x_t)} \right) dx_1dx_2...dx_T.
\]</span> PMCMC employs the sequential Monte Carlo (SMC) to approximate this likelihood for better efficiency. The posterior distributions of <span class="math inline">\(x_t\)</span>’s are represented by a set of samples (referred to as “particles”), which is sequentially sampled for <span class="math inline">\(t=1,2,...,T\)</span>. For each time step <span class="math inline">\(t\)</span>, SMC simulates the current state <span class="math inline">\(\{x_t\}\)</span> based on the previous state samples <span class="math inline">\(\{x_{t-1}\}\)</span> and weight them based on the stepwise likelihood <span class="math inline">\(g(y_t;x_t)\)</span>, so that the resulting samples provide a Monte Carlo integration. The model parameters are then searched using MCMC based on the approximated likelihood.</p>
<p>For further details and formal introduction to the PMCMC method, see <a href="https://doi.org/10.1016/j.epidem.2019.100363">Endo et al. (2019)</a>.</p>
</div>
<div id="deterministic-sir-model" class="section level2">
<h2>Deterministic SIR model</h2>
<p>First, we take the determinisitic Susceptible-Infectious-Recovered (SIR) model as an example. Although PMCMC is not necessary to fit the deterministic SIR model to data because the likelihood can be directly computed, we will introduce it for a comparison with the stochastic SIR model example later, which PMCMC is better suited for.</p>
<div id="model-specifications" class="section level3">
<h3>Model specifications</h3>
<p>The SIR model is a simple compartmental model widely used in infectious disease epidemiology. The model categorises the population into three classes: <span class="math inline">\(S\)</span> (not yet infected but at risk), <span class="math inline">\(I\)</span> (infected and currently infectious) and <span class="math inline">\(R\)</span> (previously infected but not infectious anymore), and characterises the transitions between the classes by a set of ordinary differential equations.</p>
<p><span class="math display">\[\begin{cases}
\frac{d}{dt}S(t)=-\beta S(t)I(t) \\
\frac{d}{dt}I(t)=\beta S(t)I(t) - \gamma I(t) \\
\frac{d}{dt}R(t)=\gamma I(t)
\end{cases} \]</span></p>
<p>SIR model runs on continuous time and we can get the state of each compartment at given time <span class="math inline">\(t\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1"><span class="co"># deterministic SIR model by {idmodelr}</span></a>
<a class="sourceLine" id="cb2-2" title="2">simulate_detSIR&lt;-<span class="cf">function</span>(betatau,N,times){</a>
<a class="sourceLine" id="cb2-3" title="3">  parameters &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="dt">beta =</span> betatau[<span class="dv">1</span>], <span class="co">##Transmission rate = contact rate * transmission probablity</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="dt">tau =</span> betatau[<span class="dv">2</span>] <span class="co">## Rate recovcery = 1 / duration of infection</span></a>
<a class="sourceLine" id="cb2-6" title="6">  )</a>
<a class="sourceLine" id="cb2-7" title="7">  inits &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="dt">S =</span> N<span class="dv">-1</span>,</a>
<a class="sourceLine" id="cb2-9" title="9">    <span class="dt">I =</span> <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="dt">R =</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-11" title="11">  )</a>
<a class="sourceLine" id="cb2-12" title="12">  traj &lt;-<span class="st"> </span><span class="kw">simulate_model</span>(<span class="dt">model =</span> SIR_ode,</a>
<a class="sourceLine" id="cb2-13" title="13">                       <span class="dt">sim_fn =</span> solve_ode,</a>
<a class="sourceLine" id="cb2-14" title="14">                       <span class="dt">inits =</span> inits,</a>
<a class="sourceLine" id="cb2-15" title="15">                       <span class="dt">params =</span> parameters,</a>
<a class="sourceLine" id="cb2-16" title="16">                       <span class="dt">times =</span> times)</a>
<a class="sourceLine" id="cb2-17" title="17">  <span class="kw">return</span>(traj)</a>
<a class="sourceLine" id="cb2-18" title="18">}</a>
<a class="sourceLine" id="cb2-19" title="19"></a>
<a class="sourceLine" id="cb2-20" title="20">times &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="fl">0.1</span>)</a>
<a class="sourceLine" id="cb2-21" title="21">traj&lt;-<span class="kw">simulate_detSIR</span>(<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>),<span class="dv">1000</span>,times)</a>
<a class="sourceLine" id="cb2-22" title="22"></a>
<a class="sourceLine" id="cb2-23" title="23"><span class="co"># plot the epicurve</span></a>
<a class="sourceLine" id="cb2-24" title="24"><span class="kw">plot_model</span>(traj, <span class="dt">facet =</span> F)</a></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAt1BMVEUAAAAAADoAAGYAOpAAZrYlhI46AAA6ADo6AGY6kNtEAVRNTU1NTW5NTY5NbqtNjshmAABmADpmtv9uTU1uTW5uTY5ubqtuq+SOTU2OTW6OTY6OyP+QOgCQkDqQkGaQtpCQ27aQ2/+rbk2rbm6rbo6ryKur5P+2ZgC22/+2//+73yfIjk3I///bkDrb///kq27k///r6+v/tmb/yI7/25D/27b/29v/5Kv//7b//8j//9v//+T///8riQD2AAAACXBIWXMAAA7DAAAOwwHHb6hkAAANd0lEQVR4nO2dDXvcJhLH16nlxJu0dd1r0zu7L+7bXmxv2qz3asfR9/9cJxBCIDEa3mE383+eZG0PEui3A0hogFVLWtSqdAFqFwFCRIAQESBEBAgRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQESBEBAgRAUJEgBARIEQECFEgoO1qtTq5cTrkf/8NTZBVQYCer794zyBdOhyzf4nwRBNIPV2sVi/e2eb7yjLl/qz70sfzBgHaMD4dof7DMv9ogJ4uLh3ytgfEE8rzhgDiJRR6vl6tTtnV/dx9AefsW7jsfvlptWIZ8S/lvMv6R/bldGY1FT+0+8L6P16yP57L067n0q/k6RsFZzPT9LqFbmeaJpTJQwAp3/Xz9Sn/tz/rgGwZle2Ld/uzF+/YH/uvmv1+2h+kpWIp2BfW/7FLpXrQEqC+gquKCCiKByl57lid3TEGl8xhLjmI4fOf9632e6ul4od2DOVRtoC6DCc9RBxAvA2S7CN50I7XJHF1w3/8k7vPjnd20qil2q6GenczB+RSBiShSxu0G7nHaIO6dmAR0NPFyY1m1AGJL8sZ0O6U/b+x7ELdGultnF5MXFt3No58JxoQeam80rx6x+ntIA8avi1nQPz70RrpJbkB4g0jV6T7INlI64D6Jpgh2J+djFVOS8VPouBT+8Zlsfsg67tUx25+fya60sA76c1wJy27ea2K/cT/yFKd/NI1w9w3NqtTLRU/9ERxq83qFMk1p1I+i7k1t5WKACEiQIhouAMRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQESBEBAgRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQRQL04WgNBAgxECDEQIAQAwFCDIuAHr+7b9uPP7z+6u/pR9YyFjUsAXp4/eV9++nXq/avrycfectY1LAA6O7NH50HffzPPfMk/WOWdhKfG7eMRQ1oFXv8/u/247//1D+G00nNw5k/HLisAT18xZHoH7OUhoDvPuq7Mn9wNwR5kHZiiJG56tXGATSggOzaoNmJUUSVcQANKKBPv77tuy/1wzbHBUSVcQAN6e+DAESVcQANOe6kjYQq4wAa8jxqGAhVxgE05HoWmxGqjANoyPawOiVUGQfQkO9pfkKoIg7KxMOiwx06oaKA5lMyawCkEyoCCARTByCNUFZACJalU+UdUVQIZQOEIMFOlXnIdSSUBRAEpsperJcklBzQksdUDEgSSgoIq041A2rTA8LbmtoBrd2OcDMocA7rTlqqJ5QIkOY5xQF5joenGtIfb/ciKAogBZWLIc1ovtVtn7uhyKvnFIBMzfIhA1pHBmTssw4WUBsbENClHzQg4HWZ/+BFlFPVAqiNCGjhlpAAtQvu41GqugBBhNxO5Th44W4oFWEWCRDHk/S5tyCgCFEN8R65QEOxGMUIgIbqdbSAAmPSZPNznIA+hAIam2cCZDL4jTC7G4oCCoisUnv3IwUENdPW42JBmVsbDhNQ/GEf0IAC+us10xX//PI+ZqQ9UMcsAQVmbm2w8iAW/Ht3xX6KGmnvDei2MkAs7vfTbzz21zrK1cbgCyjFwCFosAHEXKarWqyiQZH2Xlr7jd7HGpZflgMgDuTxX9yLoEh7v+/KKz54/vhe2oMeZKt8d7UQae9RFF9AUTK3NFgAunsrf7qK2gaZ+zHkVGGhCO4GHFDfPDM3+vT7vWOkPWZwB5Tq5QVowAGJGtXdB735M/aMQy9AsTK3M5Sds+o8R8E4wHrEgEwutHREutdfoOHgAEXM3MqgAep3bbHfkiq8KG6zXBK+HwQNKqBxtw1neRfFBVDK94OgQQVkv+VHvKI4AoqbuY1B96AigGznSYGvCPO1QTuP1ie0KNaA0r5hBg16FVvlbqTdAEXP3MJQfHET25l2cYJ63Q3FAc1cyHxE6hgF0KAD4rvFnc8S4coBKCkH0KAB2vbbDXoQCgOEz9W8rQKQuA/y6ctCimIJKC0H0HAYgNKHAYGGoCoWZ3jcYuw+yzC9LiOgIo301IUMR2SIkwIN5bt5O0CheXgbDgFQjkAy0CAB8Q1jCzxqtPiE+hyBZKChBg9qlwFlibQDDRV08xaAIuTha6gFELwkQ55QRNAwAhK7dq9WPhvlBhYFARQlD09D6SHXXguA4s5AdTdU0UgjgOLk4Wko/NpHCF71JFe0L2jQB+3Pn68vvSpaaFGWAMXKw88wbYM25+2ObSLvqFSAsoVDg4YpoO1pgW4eXjcnWzg0aNDaoA2nsy3gQa0ZUL54cdCgAeoaoXazOvHYBD0doIh5eBnq6OYBQBkD6kEDDkgPsU+1pr1xaaqM8eKgQRnukI8aeiOthdinW9O+ekCQ9BD7uFGuqgyAcs44AA0oID3EPmqkvSbD0H2BofpRJkDGEUU9xD5upL2m2epvWadkgIa5Bz19M+/mZYh93Eh7TSZAsfPwMBiqmOFRQ4bYp2uDZoBm4Qr1ANKqmB5iHznSXtV0/cC8c1ZAgwHQRvcgPcQ+4d4+OqDMk3pAg6GRLvKo0RoAJcjD3VDLo0Y7XWCRAM3/pALKPesJNBiCF3xG7lMASpKHs6F8hNkoBVD2aWGgoYoXh0LKGqbZZz2BhpoAtbUDaneshy9XxUZA+efNgQbTw6rHq7FogNYDoFR5uBpq6ublIq8FJhaChloBpcvD0VBDEOcosQputYAK3we1YhXcEjMvQUNV3fwIKGUebob6AK2LTE0FDRVE2mvqASU4sauMgIo30tyFikxNBQ11dfOdwBpGgHqBDlQe0MYr+C5eUXoVmtwMGkZAbKx+60soKiDzEqalAfFVBbyXFogLKGiR18gGdTJLH0HlpWhlvCVAywbOhwCBht6BatqAvT5AYcsERzfgEWZWigioYfJdBTe+oa4bxdsBUNMky8PRUB2gRipRHo6GmgA1vQOxn0yIPntADQPUcMN6bSD0uQNqOCBhWAtEkfPwMFQDqOejAOorWtQ8fAw4oMdvWRhwgjXtNTWDA0lAM0KVAmIxrSwUOMGa9qqkAwlDf7OoEaoU0APDcXeVYk17RaMDjYCmhCoFxNR5UYo17UcxDpPAehF5zy0l5AKIxf4mWdNeivnJdAUK8UQ2+lC1HvTxh2HN9thr2g9qBCDNsJ4SqhXQ47dXw4+x17QXalQHGg1TQpUCEnzSrGnfiwMwLLAwDHsIQpUCUvb2ib+mPZfuQDoglVClgOwUUJRGdyD1CJ3QZwwIXIFCji3y3j5B5rihOKCpA00BrdVksTO3MNQAaGEFCitCRw1o5kCTI8YBfGAgNiRzG0MFgBZXoFhbEDpmQHMHmh6hrDgAETpiQM3cgWZHSEIfoIbouAG16AIL6mRWI6HjBWRyIMMR6lTE7O+DSgJqTA5kOkKZJ2UidMyAWrsFFtYiBJ8p8/uggoDMDmQ+ghNSbhnzvQ8qB6gxOxBwxFpBNCV0vIBal/UDYET1AgoZFBej8S5h9QLRcHTawfwogBRUrgaogi2favQi1Yfq9aCAooB8kFOZEB0jIKAHsznVepAMADlCQHAFszmVTijxWGwRQGIA1X/u7hRRlFKZDSUAia89cOalhihdXGwBQOIlTvjEwgki9W7bvVSQIT+gpfbH8VRcM0SqwoubHRDGx/uxDkDkpvKAUD4BQ0vs1KGEZifPC6jB+Xg3HM0gxXBoHtSMQ4gpNuRrmgkk51MVBtQXneNJtN9c02iQDqsXU/Hcxim80TCBFJpHLkB9eSWexA9QGKTKAA0lVfAkBtS2E0gTUBUBmsDJvEvGDJJAlRCQfYTZDM3yC9RkBgCS2beCAUGR9jKv2yXZX1UCgwUoU5CWIyAoynWRywyO/VUlMaQEBEXaL6FJOrYeQyogKU9AUKQ96CkFHaXIjWLCNe0rNURqgyq7qogG514s2Zr2lRrS3QcdiaF0EGf1BgKEGCIBOl4RIEQECBEBQkSAEBEgRAQIEQFCRIAQBQIaH82Ah7SZxGIyrVxPBtWYzjKPYaK2fR58gMJ8LWGAxiFqaLB6qmExmXbYwBWXTGebB9NDf4V2eTwwiMC1hAEah4eggaJZWfrFZFq5gSuqMZ1tHm07DOrZ5XH35o/urMC1hAEaBxihoUaT+nRiPRk8tUznkIdwANs8GA7gWsIAjUPU0GC1QWzQrZUbuKLJx3T2eQyprPPoAAHXkt+DxsVkWsd2yD6PB7Utt8gjmQe5t0HqYjKtIyD7NujurfqLHaAkbdA4RA0NVs+KIvmI9WTQI8Z0tnmMtco2D4YDuJYo90H8C3C6R2FHiPVkbA7p0jnkMdQU+zyU+6BpPnQnjYgAISJAiAgQIgKEiAAhqhjQ8zVfXH9/dlqyFBUD6tCwPRrYljoFVTMgvtXQ/sxzN51IqhrQ08Vpu2EV7Pm638xif8Y3iNu/+tF/IytHVQ2o3Z38/PKG8ekobb94zzdH6dwqZ7NUN6DOc1gztOv3Xrz8h7VG+5c3Oatd3YDEjp3bfseYjtWu+zi52TO3yqTDACQ6sqeLkxvuQQRoUA+Ib/POPhmoHXmQoh7Q83VHpgPDQO3PCJAisWsw6+aZF226j18uLglQRSJAiAgQIgKEiAAhIkCICBAiAoSIACEiQIj+D9n82bOAgUp2AAAAAElFTkSuQmCC" /><!-- --></p>
<p>However, we usually do not observe infections on continuous time: outbreak data is usually reported as incidence on discrete time steps (e.g. weekly case counts). Therefore, we need to assume certain obervation processes when we fit the model to the observed data.</p>
<p>One of the options is to assume the reported number of cases follows a Poisson distribution whose mean is equal to the ascertainment probability <span class="math inline">\(p\)</span> times the cumulative amount of the newly-infected (i.e., inflow into the <span class="math inline">\(I\)</span> compartment) in SIR model. Here we assume <span class="math inline">\(p\)</span> is an unknown constant. Let <span class="math inline">\(C_n\)</span> be the number of cases observed over the period between <span class="math inline">\(t=T_{n-1}\)</span> and <span class="math inline">\(t=T_{n}\)</span>. We then get</p>
<p><span class="math display">\[ \begin{matrix}
C_n &amp; \sim &amp; \operatorname{Pois}(pc_n), \\
c_n &amp; = &amp; \int_{T_{n-1}}^{T_{n}}\beta I(t)S(t)dt \\
&amp; = &amp; S(T_{n-1})-S(T_{n}). \\
%&amp; = &amp; S(T_{n-1})\left[1-\exp\left(-\int_{T_{n-1}}^{T_{n}}\beta I(t)dt\right)\right]
\end{matrix}
\]</span></p>
<p>We can consider this system as an HMP. For discrete time steps <span class="math inline">\(n=1,2,...,N\)</span>, <span class="math inline">\(S(T_n)\)</span>, <span class="math inline">\(I(T_n)\)</span> and <span class="math inline">\(R(T_n)\)</span> constitute the (hidden) states of the HMP. The ODEs provide the time-evolution process and the Poisson distributions are the observation process.</p>
<p>Although we introduced PMCMC as an inference tool for HMPs, we do not need to use PMCMC for this deterministic setting because the likelihood is directly available without particle approximation. Given parameters <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma\)</span>, the likelihood of observing <span class="math inline">\(C_1, C_2, ..., C_N\)</span> cases is computed as below.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1"><span class="co"># Likelihood for the deterministic SIR model</span></a>
<a class="sourceLine" id="cb3-2" title="2">C_n &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">18</span>, <span class="dv">91</span>, <span class="dv">96</span>, <span class="dv">42</span>, <span class="dv">17</span>, <span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>)  <span class="co"># Observed case counts</span></a>
<a class="sourceLine" id="cb3-3" title="3">T_n &lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">10</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span>  <span class="co"># Time frame of observation</span></a>
<a class="sourceLine" id="cb3-4" title="4">getc_n &lt;-<span class="st"> </span><span class="cf">function</span>(traj, T_n) {</a>
<a class="sourceLine" id="cb3-5" title="5">    S_T &lt;-<span class="st"> </span><span class="kw">pmax</span>(<span class="kw">unlist</span>(traj[, <span class="st">&quot;S&quot;</span>])[T_n], <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3-6" title="6">    c_n &lt;-<span class="st"> </span>(S_T[<span class="op">-</span><span class="kw">length</span>(S_T)] <span class="op">-</span><span class="st"> </span>S_T[<span class="op">-</span><span class="dv">1</span>])</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">return</span>(c_n)</a>
<a class="sourceLine" id="cb3-8" title="8">}</a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10">logl_detSIR &lt;-<span class="st"> </span><span class="cf">function</span>(parms, C_n) {</a>
<a class="sourceLine" id="cb3-11" title="11">    beta &lt;-<span class="st"> </span>parms[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb3-12" title="12">    tau &lt;-<span class="st"> </span>parms[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb3-13" title="13">    p &lt;-<span class="st"> </span>parms[<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb3-14" title="14">    traj &lt;-<span class="st"> </span><span class="kw">simulate_detSIR</span>(<span class="kw">c</span>(beta, tau), <span class="dv">1000</span>, times)</a>
<a class="sourceLine" id="cb3-15" title="15">    c_n &lt;-<span class="st"> </span><span class="kw">getc_n</span>(traj, T_n)</a>
<a class="sourceLine" id="cb3-16" title="16">    logl &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">dpois</span>(C_n, p <span class="op">*</span><span class="st"> </span>c_n, <span class="dt">log =</span> T))</a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="kw">return</span>(logl)</a>
<a class="sourceLine" id="cb3-18" title="18">}</a></code></pre></div>
<p>Parameters can be estimated with this likelihood; e.g., by the maximum likelihood estimation or Bayesian posterior sampling.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># Maximum likelihood estimation. The true parameter values were (beta = 3.0, tau</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"># = 1.0, p = 0.3)</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">optim</span>(<span class="kw">numeric</span>(<span class="dv">3</span>) <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span>, logl_detSIR, <span class="dt">lower =</span> <span class="kw">numeric</span>(<span class="dv">3</span>) <span class="op">+</span><span class="st"> </span><span class="fl">0.1</span>, <span class="dt">upper =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">1</span>), </a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="dt">method =</span> <span class="st">&quot;L-BFGS&quot;</span>, <span class="dt">C_n =</span> C_n, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">fnscale =</span> <span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">#&gt; $par</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">#&gt; [1] 3.1572618 1.1665207 0.3039177</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">#&gt; $value</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co">#&gt; [1] -22.99954</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">#&gt; $counts</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co">#&gt; function gradient </span></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co">#&gt;       22       22 </span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co">#&gt; $convergence</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co">#&gt; [1] 0</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="co">#&gt; $message</span></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="co">#&gt; [1] &quot;CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH&quot;</span></a></code></pre></div>
</div>
<div id="model-fitting-by-mcmc" class="section level3">
<h3>Model fitting by MCMC</h3>
<p>In this section, we show how the deterministic SIR model can be fitted to the observed data. For better comparison with the stochastic SIR model case in the later section, we incrementally evaluate the likelihood by following time steps rather than in one shot. Here, <code>getSIR(n)</code> returns the hidden state variables at step <span class="math inline">\(n\)</span> (i.e. <span class="math inline">\(S(t_n)\)</span>, <span class="math inline">\(I(t_n)\)</span> and <span class="math inline">\(R(t_n)\)</span>) and <code>observe(C_n, c_n, p)</code> gives the incremental likelihood of observing <span class="math inline">\(C_n\)</span> cases given <span class="math inline">\(\lambda_n\)</span> and <span class="math inline">\(p\)</span>. Assuming improper uniform priors on the positive real line, MCMC is implemented targeting the likelihood function.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="co"># Stepwise likelihood compuation and MCMC</span></a>
<a class="sourceLine" id="cb5-2" title="2">getSIR &lt;-<span class="st"> </span><span class="cf">function</span>(n, SIRobj) {</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">S =</span> S, <span class="dt">I =</span> I, <span class="dt">R =</span> R))</a>
<a class="sourceLine" id="cb5-4" title="4">}</a>
<a class="sourceLine" id="cb5-5" title="5">observe &lt;-<span class="st"> </span><span class="cf">function</span>(C_n, c_n, p) {</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="kw">return</span>(logl)</a>
<a class="sourceLine" id="cb5-7" title="7">}</a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co"># --MCMC implementation--</span></a></code></pre></div>
<p>Because the time evolution process is deterministic, the incremental likelihood is computed without random fluctuations; <code>getSIR(n)</code> returns the fixed values and therefore the fixed incremental likelihood <code>observe(C_n, c_n, p)</code>. One the other hand, the time evolution randomly fluctuates in the stochastic SIR model (detailed in the next section). A possible approach to accounting for the stochasticity is to use many samples and approximate the likelihood by averaging over the samples, which is the key idea of PMCMC.</p>
</div>
</div>
<div id="stochastic-sir-model" class="section level2">
<h2>Stochastic SIR model</h2>
<p>Next, we show the PMCMC implementation for the stochastic SIR model, which constitutes a typical HMP with an intractable likelihood function.</p>
<div id="model-specifications-1" class="section level3">
<h3>Model specifications</h3>
<p>We adopt the Gillespie algorithm to incorporate stochasticity into the SIR model. The three variables <span class="math inline">\(S\)</span>, <span class="math inline">\(I\)</span> and <span class="math inline">\(R\)</span>, are now all considered as integers, and we assume that each individual transitions between compartment randomly according to the following rates:</p>
<p><span class="math display">\[\begin{matrix}
r_{S\rightarrow I}&amp;=&amp;\beta I(t), \\
r_{I\rightarrow R}&amp;=&amp;\gamma.
\end{matrix}\]</span> Assuming that transitions of more than one individuals do not happen exactly at the same time, we can characterise the time evolution of the stochastic SIR model as a random sequence of the two events:</p>
<ul>
<li>“New infection”: <span class="math inline">\((S,I,R)\rightarrow (S-1,I+1,R)\)</span></li>
<li>“New recovery”: <span class="math inline">\((S,I,R)\rightarrow (S,I-1,R+1)\)</span></li>
</ul>
<p>Because the number of individuals in each compartment stays constant between the successive two events, the transition rates are also constant meanwhile. Note that the next earliest happening of an event is the earlier of either “one of the <span class="math inline">\(S\)</span> susceptible individuals gets infected” or “one of the <span class="math inline">\(I\)</span> infectious individuals recovers”. The time between the two successive events (where the time of the first event is <span class="math inline">\(t_k\)</span>) therefore follows an exponential distribution with the rate <span class="math display">\[r_{\mathrm{Next}}=r_{S\rightarrow I}S(t_k)+r_{I\rightarrow R}I(t_k)=\beta S(t_k)I(t_k)+\gamma I(t_k).\]</span></p>
<p>The Gillespie algorithm simulates the epidemic by the following steps. For complete program code examples, see <a href="http://epirecip.es/epicookbook/chapters/sir-stochastic-discretestate-continuoustime/r">epirecipes</a> or <a href="https://github.com/seabbs/idmodelr/tree/master/R">{idmodelr} package repository</a>.</p>
<ol style="list-style-type: decimal">
<li>Start with the initial condition <span class="math inline">\(S(0),I(0),R(0), t_0=0.\)</span></li>
<li>For <span class="math inline">\(k=1,2,...,\)</span> sample the time of the <span class="math inline">\(k\)</span>-th event: <span class="math display">\[t_k\sim \mathrm{Exp}(r_{\mathrm{Next}}).\]</span></li>
<li>Randomly determine whether the <span class="math inline">\(k\)</span>-th event is “new infection” or “new recovery” according to the relative ratio between <span class="math inline">\(r_{S\rightarrow I}\)</span> and <span class="math inline">\(r_{I\rightarrow R}\)</span>: <span class="math display">\[\begin{matrix}
p(``\text{new infection}&quot;)&amp;=&amp; \frac{r_{S\rightarrow I}S(t_{k-1})}{r_{S\rightarrow I}S(_{k-1})+r_{I\rightarrow R}I(_{k-1})}, \\
p(``\text{new recovery}&quot;)&amp;=&amp; \frac{r_{I\rightarrow R}S(_{k-1})}{r_{S\rightarrow I}S(_{k-1})+r_{I\rightarrow R}I(_{k-1})}.
\end{matrix}
\]</span></li>
<li>Update the state variables and obtain <span class="math inline">\((S(t_k),I(t_k),R(t_k))\)</span> according to the type of event.</li>
<li>Repeat 2-4 until <span class="math inline">\(t_k\)</span> exceed the simulation stop time <span class="math inline">\(t_k\)</span>.</li>
</ol>
<p>The output of the Gillespie algorithm,<span class="math inline">\(\{S(t_k),I(t_k),R(t_k)\}\)</span> for <span class="math inline">\(k=1,2,...\)</span>, can then be translated into a continuous-time epidemic time series. {idmodelr} supports epidemic simulations with the Stochastic SIR model.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="co"># Stochastic SIR simulation by {idmodelr} plot the epicurve</span></a></code></pre></div>
<p>As we did for the deterministic SIR model, we can incorporate an observation process (underreporting) into the model. <span class="math inline">\(C_n\)</span>, the number of observed cases between time <span class="math inline">\(T_{n-1}\)</span> and <span class="math inline">\(T_n\)</span>, is given as <span class="math display">\[\begin{matrix}
C_n&amp;\sim&amp;\operatorname{Bin}(c_n,p), \\
c_n&amp;=&amp;S(T_{n-1})-S(T_n),
\end{matrix}\]</span> where <span class="math inline">\(c_n\)</span> is the number of “new infection” event occurrences between time <span class="math inline">\(T_{n-1}\)</span> and <span class="math inline">\(T_n\)</span>. The system consisting of the hidden states <span class="math inline">\(S(T_n), I(T_n),R(T_n)\)</span> and <span class="math inline">\(c_n\)</span> for discrete time steps <span class="math inline">\(n=1,2,...,N\)</span> is an HMP. Unlike the case of deterministic SIR model, the likelihood function for observed data <span class="math inline">\(\{C_1,C_2,...,C_N\}\)</span> is intractable and PMCMC needs to be employed to efficiently estimate the model parameters with the approximated likelihood.</p>
</div>
<div id="model-fitting-by-pmcmc" class="section level3">
<h3>Model fitting by PMCMC</h3>
<p>We implement PMCMC to estimate the parameters from the observed data <span class="math inline">\(\{C_1,C_2,...,C_N\}\)</span>. The function <code>simulateSIR_stoch(n)</code> simulates the stochastic SIR model from <span class="math inline">\(t=T_{n-1}\)</span> to <span class="math inline">\(T_n\)</span> and <code>observe_stoch(C_n, c_n, p)</code> gives the incremental likelihood corresponding to the observation <span class="math inline">\(C_n\)</span>. Improper uniform priors on the positive real line are assumed.</p>
<p>The SMC part of PMCMC starts off with a set of initial particles all corresponding to the initial state <span class="math inline">\(S(0)=999, I(0)=1, R(0)=0\)</span>. For each time step <span class="math inline">\(n\)</span>, the time evolution of the stochastic SIR model is simulated for each particle. Then the particles are weighted by the incremental likelihood and resampled to yield the samples that approximate the total likelihood. In the MCMC part, the parameter values are updated by the Metropolis Hastings algorithm based on the approximated likelihood.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="co"># Stepwise likelihood compuation and MCMC</span></a>
<a class="sourceLine" id="cb7-2" title="2"> simulateSIR&lt;-<span class="cf">function</span>(n, SIRobj){<span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">S=</span>S,<span class="dt">I=</span>I,<span class="dt">R=</span>R))}</a>
<a class="sourceLine" id="cb7-3" title="3"> observe&lt;-<span class="cf">function</span>(C_n,c_n,p){<span class="kw">return</span>(<span class="kw">dbinom</span>(C_n,c_n,p,<span class="dt">log=</span>T))}</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">#</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="co"># --PMCMC implementation--</span></a></code></pre></div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
